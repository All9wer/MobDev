# Практическое задание №3

## Введение

На прошлом практическом занятии был изучен способ вызова Activity,
основой которого являются «action», «data», «category» и «IntentFilter». Активность
приложения передает «intent» операционной системе (ОС) «Android», которая
проверяет его, а затем вызывает требуемую активность, даже если данная
активность находится в другом приложении

### Действие

Действия — стандартный механизм, при помощи которого ОС «Android»
узнает о том, какие стандартные операции могут выполняться активностями.
Например, ОС «Android» знает, что все активности, зарегистрированные для
действия «ACTION_SEND», могут отправлять сообщения. Иными словами, если
параметры намерения совпадают с условиями фильтра, то приложение (активность)
будет вызвано. Система сканирует активности всех установленных приложений,
и если находится несколько подходящих активностей, то ОС «Android»
предоставляет пользователю выбор, какой именно программой следует
воспользоваться.

### Информация

Идентификатор «Data» позволяет указать тип данных, с которым может
взаимодействовать компонент приложения. При необходимости возможно задать
несколько тегов «data». Чтобы указать, какие именно данные поддерживает
компонент, используется сочетание следующих атрибутов:

- «android:host» – задается доступное имя удаленного сервера (например, «google.com»);
- «android:mimetype» – позволяет указать тип данных, которые компонент
способен обрабатывать.
- «android:path» – задает доступные значения для пути URI (например,
«/transport/boats/»). Uri – это объект, который берет строку, разбирает ее на
составляющие и хранит в себе эту информацию. Строка составляется
в соответствии с документом RFC 2396. Uri имеет набор методов, которые
позволяют извлекать из разобранной строки отдельные элементы.
- «android:port»– указывает доступные порты для заданного сервера;
- «android:scheme» – это протокольная часть пути URI, например «http»,
«https», «mailto:» или «tel:».

### Категория

Применение поля «Category» позволяет выполнить описание характеристик
операции, обрабатывающей объект «Intent». Система поддерживает несколько
разных категорий, но большинство из них используется редко. Однако по
умолчанию все неявные объекты «Intent» определяются с «CATEGORY_DEFAULT».
Обозначается в фильтре намерений тэгом <category>. Далее перечислены основные
типы категорий:

Категория\Описание

- Intent.CATEGORY_DEFAULT - Используется по умолчанию для обработки неявных Intent
- Intent.CATEGORY_LAUNCHER - Активность может быть начальной деятельностью задания
из списка приложений в группе «Application Launcher»
устройства
- Intent.CATEGORY_BROWSABLE - Позволяет открывать ссылки в браузере или приложениях
- Intent.CATEGORY_HOME - активность отображает домашний экран, первый экран,
который пользователь видит после включения устройства и
загрузки системы или при нажатии клавиши «HOME»
- Intent.CATEGORY_APP_EMAIL - Запуск почтового клиента
- Intent.CATEGORY_APP_MESSAGING - Запуск приложения для сообщений
- Intent.CATEGORY_APP_GALLERY - Запуск галереи

Для работы с категориями в классе «Intent» определена группа методов:

- «addCategory» – помещает категорию в объект Intent;
- «removeCategory» – удаляет категорию, которая была добавлена ранее;
- «getCategories» – получает набор всех категорий, находящихся
в настоящее время в объекте Intent

### Передача данных с помощью Intent

Для передачи данных между двумя активностями используется объект
«Intent». С помощью вызова метода «putExtra» возможно добавить ключ и связанное
с ним значение. Область «extraData» содержит список пар ключ/значение, который
передаётся вместе с намерением. В качестве ключей используются строки, а для
значений любые примитивные типы данных, массивы примитивов, объекты класса
«Bundle» и др.

Многократные вызовы «putExtra» позволяют добавить в «intent» наборы
данных. При таком способе передачи данных следует обратить внимание, чтобы
каждому экземпляру было присвоено уникальный ключ.

Многократные вызовы «putExtra» позволяют добавить в «intent» наборы
данных. При таком способе передачи данных следует обратить внимание, чтобы
каждому экземпляру было присвоено уникальный ключ.

## 1.5 Задание

Создайте 2 activity. Проверьте наличие записи о новом активности в manifest -
файле. В первой активности требуется получить системное время с помощью
следующего участка кода:

```java
long dateInMillis = System.currentTimeMillis();
String format = "yyyy-MM-dd HH:mm:ss";
final SimpleDateFormat sdf = new SimpleDateFormat(format);
String dateString = sdf.format(new Date(dateInMillis));
```

Далее требуется передать время из одной активности в другую и отобразить
во второй activity в «textView» следующую строку: «КВАДРАТ ЗНАЧЕНИЯ
МОЕГО НОМЕРА ПО СПИСКУ В ГРУППЕ СОСТАВЛЯЕТ ЧИСЛО, а текущее
время ВРЕМЯ».

Содержание файла MainActivity:

![alt text](img/image1.png)

Содержание файла activity_main:

![alt text](img/image2.png)

Содержание файла Second_Activity:

![alt text](img/image3.png)

Содержание файла activity_second:

![alt text](img/image4.png)

Результат:

![alt text](img/image5.png)

![alt text](img/image6.png)

### Обмен данными и передача данных

Для отправки различных сообщений типа электронного письма, SMS, MMS
и т.д. применяется действие «ACTION_SEND». Метод «setType», требуется для
установки типа MIME для передаваемых данных, хранящихся в параметре
намерения «extras» с ключами EXTRA_TEXT или EXTRA_STREAM, в зависимости
от типа. Если на устройстве установлено приложение с intent-фильтром, которое
соответствует «ACTION_SEND» и MIME-типу «text/plain», система «Android»
запустит его, а если будет найдено более одного приложения, то система отобразит
диалоговое окно со списком удовлетворяющих запросу приложений

### Получение данных 

Ранее были представлены намерения, которые активируют другую
активность, не ожидая получить в ответ на это результат. Далее рассматриваются
более сложные действия, возвращающие значения. Например – при создании SMS,
производится выбор адресата, система показывает экран со списком из адресной
книги, пользователь выбирает нужного абонента и возвращается в экран создания
SMS номер контакта. Т.е. пользователь вызвал экран выбора абонента,
возвращающий контакт.
Предназначение действия «ACTION_PICK» (обобщённое название для
действий с возвращающим значением) заключается в том, чтобы запустить
активность, отображающую список элементов. После этого активность должна
предоставлять пользователю возможность выбора элемента из этого списка. Когда
пользователь выберет элемент, активность возвратит URI выбранного элемента
вызывающей стороне. Таким образом, возможно многократно использовать
Рисунок 1.2 – Диалоговое окно выбора приложения
функцию UI для выбора нескольких элементов определенного типа. Для примера
требуется вызвать приложение «Камера» и произвести снимок.
Приложения разработчиков могут не только передавать данные запускаемой
активностью, но и ожидать от нее некоторого результата работы. Для получения
результата работы запускаемой активности необходимо использовать «Activity
Result API». «Activity Result API» предоставляет компоненты для регистрации,
запуска и обработки результатов от другой активности. Главным преимуществом
применения «Activity Result API» является то, что результат активности не связан
с самой «Activity». Это позволяет получить и обработать результат, даже в случаях,
когда активность по какой-то из причин завершила свою работу.

## 1.7 Задание 

Создать приложение с двумя экранами. Основное предназначение приложения
заключается в отображении на экране названия любимой книги разработчика
и пользователя приложением с использованием двух активностей.
Компоненты первого экрана:

- поле отображения «TextView» имеет несколько состояний: начальное
значение «Тут появится название вашей любимой книги и любимая цитата из нее!»,
«Название Вашей любимой книги: КНИГА. Цитата: Цитата»;
- кнопка «Button» с текстом «Открыть экран ввода данных» предназначена
для открытия второй активности.
Компоненты второго экрана:
- поле отображения «TextView» – «Любимая книга разработчика»;
- поле отображения «TextView» – «Цитата из книги»;
- поле ввода «EditText», со значением свойства «Hint»: «Введите название
Вашей любимой книги»;
- поле ввода «EditText», со значением свойства «Hint»: «Введите цитату из
Вашей любимой книги»;
- кнопка «Button» предназначена для отправки введенных данных
пользователя на первый экран.

В созданном модуле создаётся новое activity: «New | Activity | Empty activity |
ShareActivity».
Исходный код класса «MainActivity» представлен ниже:

```java
public class MainActivity extends AppCompatActivity {
 private ActivityResultLauncher<Intent> activityResultLauncher;
 static final String BOOK_NAME_KEY = "book_name";
 static final String QUOTES_KEY = "quotes_name";
 static final String USER_MESSAGE="MESSAGE";
 private TextView textViewUserBook;
 @Override
 protected void onCreate(Bundle savedInstanceState) {
 super.onCreate(savedInstanceState);
 setContentView(R.layout.activity_main);
 textViewUserBook = findViewById(R.id.textViewBook);
 ActivityResultCallback<ActivityResult> callback = new ActivityResultCallback<ActivityResult>() {
 @Override
 public void onActivityResult(ActivityResult result) {
 if (result.getResultCode() == Activity.RESULT_OK) {
 Intent data = result.getData();
String userBook = data.getStringExtra(USER_MESSAGE);
 textViewUserBook.setText(userBook);
 }
 }
 };
 activityResultLauncher = registerForActivityResult(
 new ActivityResultContracts.StartActivityForResult(),
callback);
 }
 public void getInfoAboutBook(View view) {
 Intent intent = new Intent(this, ShareActivity.class);
 intent.putExtra(BOOK_NAME_KEY, !!!ВАША КНИГА, А НЕ МОЯ!!!);
 intent.putExtra(QUOTES_!!!, !!!ВАША ЦИТАТА, А НЕ МОЯ!!!);
 activityResultLauncher.launch(intent);
 }
}
```

В методе обработчика «getInfoAboutBook» создается «Intent» с указанным
классом «ShareActivity». Для вызова второй активности используется явные
намерения, а для получения результата «Activity Result API» (п.1.6.2). После
отправки «Intent» «MainActivity» становится родительским для «ShareActivity».
Далее требуется самостоятельно реализовать класс «ShareActivity». Пример
получения данных и отправка приведен ниже:

```java
Bundle extras = getIntent(.getExtras();
if (extras != null) {
 TextView ageView = findViewById(R.id.textViewBook);
 String book_name = extras.getString(MainActivity.BOOK_NAME_KEY);
 String quotes_name = extras.getString(MainActivity.QUOTES_KEY)
 textView.setText(String.format("Моя любимая книга: %s и цитата %s",
book_name, quotes_name));
}

Intent data = new Intent();
data.putExtra(MainActivity.USER_MESSAGE, text);
setResult(Activity.RESULT_OK, data);
finish();
```

Стоит обратить внимание, что при отправке данных создается «Intent»
без указания вызываемого класса. Для возврата результата необходимо вызвать
метод «setResult», в который передается два параметра: числовой код результата
и отправляемые данные. Константа «RESULT_OK» означает успешное завершение
вызова. Именно данная константа передастся в параметр «resultCode» метода
«onActivityResult» в «MainActivity». Вызов метода «finish» завершает работу
«ShareActivity».

Основное:
«requestCode» = 1 – успешное завершение вызова
«resultCode» = 0, это значение константы «RESULT_CANCELED», значит вызов
прошел неудачно
Ограничений на значение статуса в методе «setResult» нет. «RESULT_OK»
и «RESULT_CANCELED» – системные общепринятые константы. Возможно
использование отличных значений, если в этом есть необходимость.
«requestCode» – ID запроса. Задается в методе startActivityForResult и проверяется
потом в onActivityResult, чтобы точно знать, на какой вызов пришел ответ.

Содержание MainActivity.java:

![alt text](img/image7.png)

Содержание activity_main:

![alt text](img/image8.png)

Содержание ShareActivity.java:

![alt text](img/image9.png)

Содержание activity_share:

![alt text](img/image10.png)

Результат:

![alt text](img/image11.png)

![alt text](img/image12.png)

![alt text](img/image13.png)

## Вызов системных приложений

С помощью атрибута «action» указывается действие «activity» (например,
просмотр или редактирование данных). Также возможно указывать объекты,
с которым эти действия нужно произвести. Для этого «Intent» имеет атрибут «data».
Один из способов присвоения значения этому атрибуту – метод «setData (Uri data)»
у объекта «Intent». На вход данному методу подается объект Uri.

Uri – это объект, который берет строку, разбирает ее на составляющие
и хранит в себе данную информацию. Строка составляется в соответствии
с документом RFC 2396. Uri имеет набор методов, которые позволяют извлекать из
разобранной строки отдельные элементы. В таблице 1.1 приведены примеры разбора
строк, выполненных согласно RFC 2396.

## 1.9 Задание

Требуется создать приложение, позволяющее отображать:

- страницу web - ресурса;
- координаты на карте;
- окно набора номера

Содержание MainActivity.java:

![alt text](img/image14.png)

Содержание activity_main:

![alt text](img/image15.png)

Результат:

![alt text](img/image16.png)

Вывод по кнопке "Позвонить":

![alt text](img/image17.png)

Вывод по кнопке "Открыть браузер":

![alt text](img/image18.png)

Вывод по кнопке "Открыть карту":

![alt text](img/image19.png)

## Фрагменты

Одной из особенностей создания приложений для ОС «Android» является то,
что одно и то же приложение может запускаться на устройствах с разными экранами
и процессорами и будет работать на них одинаково. Но это вовсе не означает, что
оно будет на них одинаково выглядеть. Чтобы интерфейсы приложения на телефоне
и планшете отличались друг от друга, требуется определить разные макеты для
больших и малых устройств.

Однако определить разные макеты для разных устройств недостаточно. Чтобы
приложение работало по-разному в зависимости от устройства, наряду с разными
макетами должен выполняться разный код «Java».

Фрагмент, как и активность, связывается с макетом. Если внимательно
подойти к его проектированию, управление всеми аспектами интерфейса может
осуществляться из кода «Java». Если код фрагмента содержит все необходимое для
управления его макетом, вероятность того, что фрагмент можно будет повторно
использовать в других частях приложения, значительно возрастает. Стоит отметить,
что фрагменты не являются заменой активности, они не существуют сами по себе, а
только в составе активностей. Поэтому в манифесте прописывать их не нужно. Но в
отличие от стандартной графических элементов, для каждого фрагмента требуется
создание отдельного класса, как для активности. В составе активности существует специальный менеджер фрагментов, который может контролировать все классы
фрагментов и управлять ими.

Фрагменты являются строительным материалом для приложения. Данный
компонент позволяет в нужное время добавить новый фрагмент, удалить ненужный
фрагмент или заменить один фрагмент на другой.

Фрагмент может иметь свою разметку, но возможно использование
и без неё. Также у фрагмента есть свой жизненный цикл, во многом совпадающий
с жизненным циклом активности. Имеются специальные виды фрагментов,
предназначенные под определённые задачи – «ListFragment», «DialogFragment»
(изучали ранее), «PreferenceFragment» и другие.

Есть два варианта использования фрагментов в приложении:

- в разметке указывается фрагмент с помощью тега «fragment»;
- динамическое подключение фрагмента. В разметку помещается макет из
группы «ViewGroup», который становится контейнером для фрагмента. Обычно, для
данной цели используют «FrameLayout», но это не обязательное условие. В нужный
момент фрагмент замещает контейнер и становится частью разметки.

Так же как активности, фрагменты должны реализовывать другие методы
обратного вызова жизненного цикла, которые позволяют управлять его состоянием,
таким как его добавление или удаление из активности, и для обработки переходов
между состояниями жизненного цикла. Например, когда для активность вызывается
метод «onPause», все фрагменты данной активности также получат вызов
«onPause».
Как правило, требуется реализовать следующие методы жизненного цикла:

- «onCreate» – система вызывает данный метод, когда создает фрагмент.
В своей реализации разработчик должен инициализировать ключевые компоненты
фрагмента, которые требуется сохранить, когда фрагмент находится в состоянии
паузы или возобновлен после остановки.
- «onCreateView» – система вызывает данный метод при первом
отображении пользовательского интерфейса фрагмента на дисплее. Для прорисовки
пользовательского интерфейса фрагмента следует возвратить из этого метода объект
«View», который является корневым в макете фрагмента. Если фрагмент не имеет
пользовательского интерфейса, можно возвратить «null».
- «onPause» – система вызывает данный метод как первое указание того, что
пользователь покидает фрагмент (это не всегда означает уничтожение фрагмента).
Обычно именно в этот момент необходимо фиксировать все изменения, которые
должны быть сохранены за рамками текущего сеанса работы пользователя
(поскольку пользователь может не вернуться назад).

## Задание 2.1

Требуется создать приложение на основе «Fragment», учитывающее
изменение ориентации экрана. Для создания фрагментов используется следующая
последовательность: «File | New | Fragment | Fragment (Blank)», указать имена
«FirstFragment&SecondFragment».

Содержание MainActivity.java:

![alt text](img/image20.png)

Содержание activity_main:

![alt text](img/image21.png)

Содержание activity_main(land):

![alt text](img/image22.png)

Содержание FirstFragment:

![alt text](img/image23.png)

Содержание SecondFragment:

![alt text](img/image24.png)

Результат:

![alt text](img/image25.png)

![alt text](img/image26.png)

![alt text](img/image27.png)

## 3 Контрольное задание

Android позволяет создать собственное окно для просмотра веб-страниц и
клон браузера при помощи элемента WebView. Сам элемент использует движок
«WebKit» или движок от «Chromium» и имеет множество свойств и методов.

Требуется создать/модифицировать два фрагмента.

- «DataFragment» – создать фрагмент с уникальной информацией об
интересующей Вас отрасли. Отразить навыки разметки, цветовая схема и отступы
должны быть выполнены согласно требованиям «Material You»;
- «WebViewFragment» – создать простейший браузер со страницей по
умолчанию.

После сборки проекта требуется запустить проект и ознакомиться с логикой
работы данного шаблона. Значок в виде трёх горизонтальных полосок в заголовке
называется «гамбургером» («Hamburger menu»). При нажатии слева отображается
навигационная шторка.

Содержимое файла DataFragment:

![alt text](img/image28.png)

Содержимое файла fragment_data:

![alt text](img/image29.png)

Содержимое файла WebFragment:

![alt text](img/image30.png)

Содержимое файла fragment_webview:

![alt text](img/image31.png)

Сожержание файла mobile_navigation:

![alt text](img/image32.png)

Сожержание файла activity_main_drawer:

![alt text](img/image33.png)

Сожержание файла strings:

![alt text](img/image34.png)

Сожержание файла MainActivity:

![alt text](img/image35.png)

Результат:

![alt text](img/image36.png)

![alt text](img/image37.png)

Нажатие на кнопку Отрасль:

![alt text](img/image38.png)

Нажатие на кнопку браузер:

![alt text](img/image39.png)